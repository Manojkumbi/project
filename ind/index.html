<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Concepts</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav>
        <span id="homespan" style="margin-left: 25px;"><a href="../index.html">Home</a></span>
        <div class="hamburger" id="hamburger">
            &#9776; <!-- This is the hamburger icon -->
        </div>
        <ul id="nav-links">
            <li><a href="#div1">Data Types</a></li>
            <li><a href="#div2">Control Structures</a></li>
            <li><a href="#div3">Functions</a></li>
            <li><a href="#div4">Objects</a></li>
            <li><a href="#div5">Arrays</a></li>
            <li><a href="#div6">Asynchronous JavaScript</a></li>
            <li><a href="#div7">DOM Manipulation</a></li>
            <li><a href="#div8">ES6 Features</a></li>
            <li><a href="#div9">Modules</a></li>
            <li><a href="#div10">Data Structures
            </a></li>
            <li><a href="#div11">Advanced JavaScript Concepts</a></li>
            <li><a href="#div12">JavaScript’s functionality</a></li>
        </ul>
    </nav>

    <header>
        <h1>Understanding JavaScript Concepts</h1>
        <p>A beginner's guide to essential JavaScript concepts.</p>
    </header>

    <div id="div1" class="concept">
        <h2>Data Types</h2>
        <p>JavaScript supports several data types, categorized as:</p>
        <ul>
            <li><strong>Primitive Types:</strong> Include strings, numbers, booleans, null, undefined, and symbols.</li>
            <li><strong>Non-Primitive Types:</strong> Include objects and arrays, which can store collections of data.</li>
        </ul>
        <p>Examples:</p>
        <pre><code>
let age = 25;                     // Number
const birthYear = 1999;          // Number
var name = "goku";                // String

let colors = ["red", "green", "blue"]; // Array
let person = { name: "John", age: 30 }; // Object
        </code></pre>
        <p>Accessing Data:</p>
        <pre><code>
console.log(colors[0]); // Output: red
console.log(person['name']); // Output: John
        </code></pre>
    </div>

    <div id="div2" class="concept">
        <h2>Control Structures</h2>
        <p>Control structures manage the flow of your program, including:</p>
        <ul>
            <li><strong>Conditional Statements:</strong> Used for decision-making.</li>
            <li><strong>Loops:</strong> Used to execute a block of code multiple times.</li>
        </ul>
        <p>Examples:</p>
        <pre><code>
let age = 18;
if (age >= 18) {
  console.log("You are an adult.");
} else {
  console.log("You are a minor.");
}

for (let i = 0; i < 5; i++) {
    if (i === 2) break; // Exits the loop when i is 2
    console.log("Number:", i); // Outputs 0, 1
}

let day = 3;
switch (day) {
  case 1: 
    dayName = "Monday"; 
    break;
  case 2: 
    dayName = "Tuesday"; 
    break;
  case 3: 
    dayName = "Wednesday"; 
    break;
  default: 
    dayName = "Unknown day"; 
}
        </code></pre>
    </div>

    <div id="div3" class="concept">
        <h2>Functions</h2>
        <p>Functions are reusable blocks of code in JavaScript, declared in different ways:</p>
        <ul>
            <li><strong>Function Declaration:</strong> Can be called before it is defined.</li>
            <li><strong>Function Expression:</strong> Can only be called after it is defined.</li>
            <li><strong>Arrow Functions:</strong> A concise syntax introduced in ES6.</li>
        </ul>
        <p>Examples:</p>
        <pre><code>
function greet(name) {
    return `Hello, ${name}!`;
}

const greetex = function(name) {
    return `Hello, ${name}!`;
};

const greetar = (name) => `Hello, ${name}!`;
        </code></pre>
        <p>Calling Functions:</p>
        <pre><code>
console.log(greet("Zoro")); // Output: Hello, Zoro!
console.log(greetex("Bob")); // Output: Hello, Bob!
console.log(greetar("Charlie")); // Output: Hello, Charlie!
        </code></pre>
    </div>

    <div id="div4" class="concept">
        <h2>Objects</h2>
        <p>Objects are collections of key-value pairs:</p>
        <p>Example:</p>
        <pre><code>
const person = {
    name: "Zoro",
    age: 25,
    profession: "Developer"
};

// Accessing properties
console.log(Object.keys(person)); // Output: ["name", "age", "profession"]
console.log(person.name); // Output: Zoro
        </code></pre>
    </div>

    <div id="div5" class="concept">
        <h2>Arrays</h2>
        <p>Arrays are used to store multiple values in a single variable:</p>
        <p>Common Array Methods:</p>
        <ul>
            <li><strong>push()</strong>: Adds an item to the end of an array.</li>
            <li><strong>pop()</strong>: Removes the last item from an array.</li>
            <li><strong>shift()</strong>: Removes the first item from an array.</li>
            <li><strong>unshift()</strong>: Adds an item to the beginning of an array.</li>
            <li><strong>concat()</strong>: Combines two or more arrays.</li>
            <li><strong>join()</strong>: Creates a string from the array's elements.</li>
            <li><strong>slice()</strong>: Returns a shallow copy of a portion of an array.</li>
            <li><strong>splice()</strong>: Changes the contents of an array by removing or replacing existing elements.</li>
        </ul>
        <p>Example:</p>
        <pre><code>
const fruits = ["apple", "banana", "orange"];
fruits.push("grape"); // Adds 'grape'
console.log(fruits); // Output: ["apple", "banana", "orange", "grape"]
        </code></pre>
    </div>
    <div id="div6" class="concept">
        <h2>Asynchronous JavaScript</h2>
        <p>JavaScript handles asynchronous code using Callbacks, Promises, and Async/Await:</p>
        <ul>
            <li><strong>Callback:</strong> A function passed as an argument to another function, often used in asynchronous operations.</li>
            <li><strong>Promise:</strong> An object representing the eventual completion or failure of an asynchronous operation.</li>
            <li><strong>Async/Await:</strong> A syntactical sugar over Promises for easier handling of asynchronous code.</li>
        </ul>
        <p>Examples:</p>
        <pre><code>
// Callback
function fetchData(callback) {
    setTimeout(() => callback("Data received"), 1000);
}
fetchData(console.log);

// Promise
let promise = new Promise((resolve, reject) => {
    let success = true;
    success ? resolve("Data received") : reject("Error");
});
promise.then(console.log).catch(console.error);

// Async/Await
async function fetchAsyncData() {
    try {
        let result = await promise;
        console.log(result);
    } catch (error) {
        console.error(error);
    }
}
fetchAsyncData();
        </code></pre>
    </div>

    <div id="div7" class="concept">
        <h2>DOM Manipulation</h2>
        <p>The Document Object Model (DOM) allows interaction with HTML elements using JavaScript:</p>
        <ul>
            <li><strong>Selecting Elements:</strong> Use <code>querySelector()</code>, <code>getElementById()</code>, or <code>getElementsByClassName()</code> to access elements.</li>
            <li><strong>Changing Content:</strong> Use <code>textContent</code> or <code>innerHTML</code> to update content.</li>
            <li><strong>Changing Style:</strong> Access the <code>style</code> property to modify CSS styles.</li>
            <li><strong>Event Listeners:</strong> Use <code>addEventListener()</code> to add events like click, input, or submit.</li>
        </ul>
        <p>Examples:</p>
        <pre><code>
let button = document.querySelector("#myButton");
button.addEventListener("click", () => {
    let message = document.getElementById("message");
    message.textContent = "Button clicked!";
    message.style.color = "blue";
});
        </code></pre>
    </div>

    <div id="div8" class="concept">
        <h2>ES6 Features</h2>
        <p>Modern JavaScript (ES6) introduces several helpful features:</p>
        <ul>
            <li><strong>Destructuring:</strong> Unpack values from arrays or properties from objects.</li>
            <li><strong>Spread and Rest:</strong> Spread allows an array or object to be expanded. Rest collects all remaining elements.</li>
            <li><strong>Template Literals:</strong> Allows embedded expressions in strings using backticks.</li>
            <li><strong>Default Parameters:</strong> Provides default values for function parameters.</li>
        </ul>
        <p>Examples:</p>
        <pre><code>
// Destructuring
const [a, b] = [1, 2];
const {name, age} = {name: "Alice", age: 25};

// Spread and Rest
let arr1 = [1, 2];
let arr2 = [...arr1, 3, 4];
function add(...numbers) { return numbers.reduce((a, b) => a + b); }

// Template Literals
let message = \`Hello, \${name}!\`;

// Default Parameters
function greet(name = "Guest") {
    console.log(\`Hello, \${name}!\`);
}
        </code></pre>
    </div>

    <div id="div9" class="concept">
        <h2>Modules</h2>
        <p>Modules allow you to split code into separate files and reuse them:</p>
        <ul>
            <li><strong>Export:</strong> Define parts of a module to be used in other files.</li>
            <li><strong>Import:</strong> Import parts of another module into your file.</li>
        </ul>
        <p>Examples:</p>
        <pre><code>
// math.js
export function add(x, y) { return x + y; }
export const PI = 3.14;

// app.js
import { add, PI } from './math.js';
console.log(add(2, 3)); // Output: 5
console.log(PI); // Output: 3.14
        </code></pre>
    </div>
    <div id="div10" class="concept">
        <h2>Data Structures</h2>
        <h3>1. Arrays</h3>
        <p>An array is a collection of elements ordered by an index and is commonly used for storing lists of values. Arrays have various built-in methods that make them versatile for data manipulation.</p>
        <pre><code>
    let fruits = ["apple", "banana", "cherry"];
    console.log(fruits[1]); // Output: "banana"
    
    // Adding and removing elements
    fruits.push("orange"); // Adds "orange" to the end
    fruits.pop();          // Removes the last element ("orange")
    console.log(fruits);    // Output: ["apple", "banana", "cherry"]
        </code></pre>
        <p><strong>Use Case:</strong> Arrays are perfect for maintaining ordered lists and support a variety of operations like filtering, mapping, and reducing.</p>
    
        <h3>2. Objects</h3>
        <p>An object is a collection of key-value pairs. Keys are strings or symbols, while values can be any data type, including functions.</p>
        <pre><code>
    let person = {
      name: "Alice",
      age: 25,
      occupation: "Developer"
    };
    
    console.log(person.name);  // Output: "Alice"
    console.log(person["age"]); // Output: 25
        </code></pre>
        <p><strong>Use Case:</strong> Objects are ideal for storing data that has a clear label, where each item can be accessed by a key. Objects are also mutable and can be expanded with new properties.</p>
    
        <h3>3. Sets</h3>
        <p>A Set is a collection of unique values, meaning duplicates are automatically ignored. Sets are useful when you want to avoid duplicate entries.</p>
        <pre><code>
    let uniqueNumbers = new Set([1, 2, 3, 3, 4]);
    uniqueNumbers.add(5);
    console.log(uniqueNumbers); // Output: Set { 1, 2, 3, 4, 5 }
    
    uniqueNumbers.delete(1);
    console.log(uniqueNumbers.has(1)); // Output: false
        </code></pre>
        <p><strong>Use Case:</strong> Sets are useful for managing unique values, such as tracking a list of visited URLs or filtering out duplicate items.</p>
    
        <h3>4. Maps</h3>
        <p>Maps store key-value pairs like objects but have greater flexibility because keys can be any data type (objects, arrays, functions, etc.).</p>
        <pre><code>
    let userRoles = new Map();
    userRoles.set("Alice", "Admin");
    userRoles.set("Bob", "User");
    
    console.log(userRoles.get("Alice")); // Output: "Admin"
    console.log(userRoles.has("Bob"));   // Output: true
        </code></pre>
        <p><strong>Use Case:</strong> Maps are excellent when you need a dictionary-like data structure with flexible key types. They also preserve the order of items as they were added, which is not guaranteed in standard objects.</p>
    
        <h3>5. WeakSets</h3>
        <p>A WeakSet is similar to a Set, but it can only contain objects as its members, not primitive values. Additionally, objects in a WeakSet are held “weakly,” meaning they can be garbage-collected if there are no other references to them.</p>
        <pre><code>
    let person1 = { name: "Alice" };
    let person2 = { name: "Bob" };
    
    let userGroup = new WeakSet([person1, person2]);
    console.log(userGroup.has(person1)); // Output: true
    
    person1 = null; // Now the object { name: "Alice" } can be garbage-collected
        </code></pre>
        <p><strong>Use Case:</strong> WeakSets are useful when you want to manage a list of objects without preventing them from being garbage-collected, like keeping track of which DOM nodes have been processed.</p>
    
        <h3>6. WeakMaps</h3>
        <p>A WeakMap is similar to a Map but only allows objects as keys (no primitive data types). The object references are also held weakly, allowing them to be garbage-collected.</p>
        <pre><code>
    let user = { name: "Alice" };
    let weakMap = new WeakMap();
    weakMap.set(user, "Admin");
    
    console.log(weakMap.get(user)); // Output: "Admin"
    user = null;                    // The entry is eligible for garbage collection
        </code></pre>
        <p><strong>Use Case:</strong> WeakMaps are commonly used when you want to associate metadata with objects without creating a memory leak, as the data will be garbage-collected when the object is no longer accessible.</p>
    
        <h3>Summary of Use Cases:</h3>
        <ul>
            <li><strong>Arrays and Objects:</strong> for general-purpose collections.</li>
            <li><strong>Sets and Maps:</strong> for handling unique values and key-value pairs.</li>
            <li><strong>WeakSets and WeakMaps:</strong> for managing collections of objects without memory leaks.</li>
        </ul>
    </div>
    <div id="div11" class="concept">
        <h2>Advanced JavaScript Concepts</h2>
    
        <h3>1. Closures</h3>
        <p>A closure is a function that remembers its outer variables, even if it's executed outside its lexical scope. Closures are commonly used for data privacy and maintaining state in JavaScript.</p>
        <pre><code>
    function makeCounter() {
      let count = 0; // This variable is closed over by the inner function
    
      return function() {
        count++;
        return count;
      };
    }
    
    const counter1 = makeCounter();
    console.log(counter1()); // Output: 1
    console.log(counter1()); // Output: 2
    
    const counter2 = makeCounter();
    console.log(counter2()); // Output: 1 (new closure)
        </code></pre>
        <p><strong>Explanation:</strong> Here, <code>count</code> is accessible only within the inner function returned by <code>makeCounter</code>. Each time <code>makeCounter</code> is called, a new closure is created, which maintains its own separate <code>count</code>.</p>
    
        <h3>2. Hoisting</h3>
        <p>In JavaScript, declarations (variables and functions) are "hoisted" to the top of their scope before the code executes. This means you can use functions and variables before they are declared, but only the declarations are hoisted, not the initializations.</p>
        <pre><code>
    console.log(name); // Output: undefined (declaration hoisted, but not initialization)
    var name = "Alice";
    
    console.log(greet()); // Output: "Hello!"
    function greet() {
      return "Hello!";
    }
        </code></pre>
        <p><strong>Explanation:</strong> Variable <code>name</code> is hoisted, but only its declaration, not its value, so it outputs <code>undefined</code>. The function <code>greet</code> is fully hoisted, so it can be called before its declaration.</p>
    
        <h3>3. Prototypes and Inheritance</h3>
        <p>In JavaScript, every object has a prototype, an object it inherits properties from. JavaScript inheritance is prototype-based, allowing one object to "inherit" properties from another.</p>
        <pre><code>
    function Animal(name) {
      this.name = name;
    }
    
    Animal.prototype.speak = function() {
      console.log(this.name + " makes a noise.");
    };
    
    const dog = new Animal("Dog");
    dog.speak(); // Output: "Dog makes a noise."
        </code></pre>
        <p><strong>Explanation:</strong> <code>speak</code> is defined on <code>Animal</code>'s prototype, making it available to all <code>Animal</code> instances. <code>dog</code> inherits this method from <code>Animal</code>'s prototype.</p>
    
        <h3>4. The <code>this</code> Keyword</h3>
        <p>The <code>this</code> keyword refers to the object that is executing the current function. Its value depends on the context in which it is called (runtime binding).</p>
        <pre><code>
    const person = {
      name: "Alice",
      greet() {
        console.log("Hello, " + this.name);
      }
    };
    
    person.greet(); // Output: "Hello, Alice"
    
    // Global context
    function sayHello() {
      console.log("Hello, " + this.name);
    }
    
    sayHello(); // Output: "Hello, undefined" in strict mode or "Hello, globalName" in the browser
        </code></pre>
        <p><strong>Explanation:</strong> In <code>person.greet()</code>, <code>this</code> refers to the <code>person</code> object. In the global context, <code>this</code> typically refers to the global object (<code>window</code> in browsers).</p>
    
        <h3>5. Scope (Global, Local, Block)</h3>
        <p>Scope defines the accessibility of variables and functions. JavaScript has three main types of scope:</p>
        <ul>
            <li><strong>Global Scope:</strong> Accessible throughout the program.</li>
            <li><strong>Local Scope:</strong> Created within functions.</li>
            <li><strong>Block Scope:</strong> Created within curly braces <code>{}</code>, for example, within <code>if</code> or <code>for</code> statements (ES6 <code>let</code> and <code>const</code> are block-scoped).</li>
        </ul>
        <pre><code>
    let globalVar = "I am global";
    
    function localScopeExample() {
      let localVar = "I am local";
      console.log(globalVar); // Output: "I am global"
      console.log(localVar);  // Output: "I am local"
    }
    
    localScopeExample();
    // console.log(localVar); // Error: localVar is not defined
    
    if (true) {
      let blockScoped = "I am block-scoped";
      console.log(blockScoped); // Output: "I am block-scoped"
    }
    
    // console.log(blockScoped); // Error: blockScoped is not defined
        </code></pre>
        <p><strong>Explanation:</strong></p>
        <ul>
            <li><code>globalVar</code> is accessible everywhere.</li>
            <li><code>localVar</code> is only accessible within <code>localScopeExample</code>.</li>
            <li><code>blockScoped</code> is accessible only within the block (<code>if</code> statement) in which it is declared.</li>
        </ul>
    </div>
    
    <div id="div12" class="concept">
        
        <h2>JavaScript’s Functionality in the Browser</h2>
    
        <h3>1. Event Loop</h3>
        <p>The Event Loop is a JavaScript mechanism that handles asynchronous operations, allowing non-blocking code execution. JavaScript runs in a single thread, so the Event Loop helps manage asynchronous tasks without halting code execution, which is crucial for handling user interactions and API requests smoothly.</p>
        <h4>How It Works:</h4>
        <ul>
            <li><strong>Call Stack:</strong> Where JavaScript keeps track of the function executions.</li>
            <li><strong>Web APIs:</strong> Asynchronous tasks (like <code>setTimeout</code>, <code>fetch</code>, etc.) are processed by browser-provided Web APIs.</li>
            <li><strong>Callback Queue:</strong> Once a task completes, its callback moves to the Callback Queue.</li>
            <li><strong>Event Loop:</strong> Constantly checks if the Call Stack is empty; if so, it pushes tasks from the Callback Queue to the Call Stack for execution.</li>
        </ul>
        <pre><code>
    console.log("Start");
    
    setTimeout(() => {
      console.log("Inside Timeout");
    }, 0);
    
    console.log("End");
    
    // Output: "Start", "End", "Inside Timeout"
        </code></pre>
        <p><strong>Explanation:</strong> Although <code>setTimeout</code> is set to zero milliseconds, its callback is still sent to the Callback Queue, so it runs after synchronous tasks (<code>console.log("End")</code>).</p>
    
        <h3>2. Browser APIs</h3>
        <p>Browser APIs provide built-in functionalities to interact with the web browser. Commonly used Browser APIs include LocalStorage, SessionStorage, and the Fetch API.</p>
    
        <h4>LocalStorage</h4>
        <p><code>LocalStorage</code> is used for storing data that persists across browser sessions. It stores key-value pairs as strings and is limited in size (typically around 5MB).</p>
        <pre><code>
    // Save data
    localStorage.setItem("username", "Alice");
    
    // Retrieve data
    const username = localStorage.getItem("username");
    console.log(username); // Output: "Alice"
    
    // Remove data
    localStorage.removeItem("username");
    
    // Clear all data
    localStorage.clear();
        </code></pre>
    
        <h4>Fetch API</h4>
        <p>The Fetch API allows for making network requests, such as retrieving data from a server. It returns Promises, enabling handling of asynchronous responses.</p>
        <pre><code>
    fetch("https://jsonplaceholder.typicode.com/posts/1")
      .then(response => response.json())
      .then(data => console.log(data))
      .catch(error => console.error("Error:", error));
        </code></pre>
        <p><strong>Explanation:</strong> <code>fetch</code> sends a GET request to retrieve data from the provided URL, and <code>.then()</code> handles the JSON response.</p>
    
        <h3>3. Web Components</h3>
        <p>Web Components are a set of standardized APIs that allow developers to create reusable custom HTML elements. Web Components consist of three main technologies:</p>
        <ul>
            <li><strong>Custom Elements:</strong> Define custom HTML elements.</li>
            <li><strong>Shadow DOM:</strong> Encapsulates styles and logic, preventing them from affecting other parts of the document.</li>
            <li><strong>HTML Templates:</strong> Define markup for reusability without rendering it until needed.</li>
        </ul>
        <p><strong>Example:</strong> Creating a simple <code>&lt;user-card&gt;</code> component:</p>
        <pre><code>
            &lt;user-card&gt;&lt;/user-card&gt;
            
            &lt;script&gt;
              class UserCard extends HTMLElement {
                constructor() {
                  super();
                  // Attach a shadow DOM
                  this.attachShadow({ mode: 'open' });
            
                  // Template content
                  const template = document.createElement('template');
                  template.innerHTML = `
                    &lt;style&gt;
                      h2 { color: blue; }
                    &lt;/style&gt;
                    &lt;div&gt;
                      &lt;h2&gt;User Card&lt;/h2&gt;
                      &lt;p&gt;Name: &lt;slot name="username"&gt;&lt;/slot&gt;&lt;/p&gt;
                    &lt;/div&gt;
                  `;
            
                  // Attach template content to shadow DOM
                  this.shadowRoot.appendChild(template.content.cloneNode(true));
                }
              }
            
              // Define the new element
              customElements.define("user-card", UserCard);
            &lt;/script&gt;
            </code></pre>
            
        <p><strong>Explanation:</strong> Here, a <code>UserCard</code> class extends <code>HTMLElement</code> to create a new <code>&lt;user-card&gt;</code> element. Shadow DOM encapsulates the element’s styles and structure, so it remains isolated from the rest of the document.</p>
    </div>
    

    <footer>
        <p>&copy; 2024 Kumaraswamy S. All rights reserved.</p>
    </footer>
</body>
<script>
document.addEventListener("DOMContentLoaded", function() {
    const hamburger = document.getElementById("hamburger");
    const navLinks = document.getElementById("nav-links");

    // Check if elements are correctly selected
    if (hamburger && navLinks) {
        hamburger.addEventListener("click", function() {
            navLinks.classList.toggle("active");
        });
    } else {
        console.error("Element not found: ", { hamburger, navLinks });
    }
});

</script>
</html>
